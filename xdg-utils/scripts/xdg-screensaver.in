#!/bin/sh
#---------------------------------------------
#   xdg-screensaver
#
#   Utility script to control screensaver.
#
#   Refer to the usage() function below for usage.
#
#   Copyright 2006, Bryce Harrington <bryce@osdl.org>
#
#   LICENSE:
#
#---------------------------------------------

manualpage()
{
cat << _MANUALPAGE
_MANUALPAGE
}

usage()
{
cat << _USAGE
_USAGE
}

#@xdg-utils-common@

screensaver_file=$HOME/.xdg-screensaver-`echo $DISPLAY | sed 's/:/-/g'`
lockfile_command=`which lockfile`

lockfile()
{
  if [ -n "$lockfile_command" ] ; then
     $lockfile_command -1 -l 10 -s 3 "$screensaver_file".lock
  else
     # Poor man's attempt at doing a lockfile
     (set -o noclobber
     local try
     try=0
     while ! echo > "$screensaver_file".lock ;
     do
        sleep 1
        try=$(($try+1))
        if [ $try -eq 3 ] ; then 
            rm -f "$screensaver_file".lock || return # Can't remove lockfile
            try=0
        fi
     done)
  fi
}

unlockfile()
{
  rm -f "$screensaver_file".lock
}

perform_action()
{
  # Always set the Xorg screensaver first
  screensaver_xset "$1"
  xset_err=$?
  
  case "$DE" in
    kde)
      screensaver_kde "$1"
      ;;

    gnome)
      screensaver_gnome "$1"
      ;;
  esac
}

cleanup_suspend()
{
  lockfile
  grep -v "$window_id:" "$screensaver_file" > "$screensaver_file".new
  mv "$screensaver_file".new "$screensaver_file"
  unlockfile
  if [ ! -s "$screensaver_file" ] ; then
      # $screensaver_file is empty, do resume"
      perform_action resume
  fi
}

do_resume()
{
  lockfile # Obtain lockfile
  # Find the PID of the trackingprocess
  xprop_pid=`grep "$window_id:" "$screensaver_file" | cut -d ':' -f 2`
  unlockfile # Free lockfile
  if [ -n "$xprop_pid" ] && ps -p "$xprop_pid" 2> /dev/null | grep xprop > /dev/null; then
     # Kill the tracking process 
     kill -TERM $xprop_pid
  fi
  cleanup_suspend  
}

track_window()
{
  lockfile

  # Filter stale entries from the xdg-screensaver status file
  # Return if $window_id is being tracked already
  (
    already_tracked=0
    IFS_save=$IFS
    IFS=":"
    while read wid pid; do
      if ps -p "$pid" 2> /dev/null | grep xprop > /dev/null; then
        echo "$wid:$pid"
        if [ $wid = $window_id ] ; then
          already_tracked=1
        fi   
      fi
    done
    IFS=$IFS_save
    exit $already_tracked
  ) < $screensaver_file > $screensaver_file.new
  already_tracked=$?
  mv $screensaver_file.new $screensaver_file

  if [ "$already_tracked" -eq "1" ] ; then
    # We are already tracking $window_id, don't do anything
    unlockfile
    return
  fi

  # Start tracking $window_id
  xprop -id $window_id -spy > /dev/null &
  xprop_pid=$!
  # Add window_id and xprop_pid to the xdg-screensave status file
  echo "$window_id:$xprop_pid" >> $screensaver_file
  unlockfile
  # Wait for xprop to edit, it means that the window disappeared
  wait $xprop_pid
  # Clean up the administration and resume the screensaver
  cleanup_suspend
}

screensaver_xset()
{
    TIMEOUT=`xset q | /bin/grep -A 2 ^Screen | /bin/grep timeout | awk '{print $2}'` 
    DPMS=`xset q | /bin/grep 'DPMS is' | awk '{print $3}'` 

    if [ "$DPMS" = "Enabled" ]; then
        DPMS="+dpms"
    else
        DPMS="-dpms"
    fi

    case "$1" in
        # New arg Window ID, create lockfile with $WINDOWID
        suspend)
        xset s off -dpms
        ;;

        resume)
        # Restores screensaver to its default settings
        xset s default "$DPMS"
        ;;

        activate)
        # Turns the screensaver on right now
        xset s activate
        ;;

        reset)
        # Turns the screensaver off right now
        xset s reset
        ;;

        status)
        if [ ${TIMEOUT:0} -eq 0 ]; then
            echo "disabled"
        else
            echo "enabled"
        fi
        ;;
    esac

    return $?
}

screensaver_kde()
{
    case "$1" in
        suspend) 
        dcop kdesktop KScreensaverIface enable false
        ;;

        resume)
        dcop kdesktop KScreensaverIface configure
        ;;
        
        activate)
        dcop kdesktop KScreensaverIface save > /dev/null
        ;;
        
        reset)
        # Turns the screensaver off right now
        dcop kdesktop KScreensaverIface quit
        ;;

        status)
        status=`dcop kdesktop KScreensaverIface isEnabled`
        if [ x"$status" = "xtrue" ]; then
            echo "enabled"
        elif [ x"$status" = "xfalse" ]; then
            echo "disabled"
        else
            echo "ERROR:  kdesktop KScreensaverIface isEnabled returned '$status'" >&2
            return 1
        fi
        ;;

        *)
        echo "ERROR:  Unknown command '$1'" >&2
        return 1
        ;;
    esac

    return $?
}

screensaver_gnome()
{
# TODO
# There seems to be a DBUS interface for gnome-screensaver
# See http://lists.mplayerhq.hu/pipermail/mplayer-dev-eng/2006-April/042579.html and
# http://cvs.gnome.org/viewcvs/gnome-screensaver/src/gs-listener-dbus.c?rev=1.36&view=log
# A problem seems to be that Inhibit is tied to the lifetime of the DBUS appname and
# this can not be used from a script
    case "$1" in
        suspend) 
        # Don't know how to suspend properly
        gnome-screensaver-command --exit
        ;;

        resume)
        # Don't know how to suspend properly
        # This may start the gnome-screensaver even if it wasn't running before
        gnome-screensaver
        ;;
        
        activate)
        gnome-screensaver-command --activate
        ;;
        
        reset)
        # Turns the screensaver off right now
        gnome-screensaver-command --deactivate
        ;;

        status)
        # Don't know how to suspend properly
        if gnome-screensaver-command --query 2> /dev/null >&2; then
            echo "enabled"
        else
            echo "disabled"
        fi
        return 0
        ;;

        *)
        echo "ERROR:  Unknown command '$1" >&2
        return 1
        ;;
    esac

    return $?
}

[ x"$1" != x"" ] || exit_failure_syntax

action=
window_id=

case $1 in
  suspend)
    action=$1
    
    shift

    if [ -z "$1" ] ; then 
        exit_failure_syntax "WindowID argument missing"
    fi
    
    window_id=$1    
    ;;

  resume)
    action=$1
    
    shift

    if [ -z "$1" ] ; then 
        exit_failure_syntax "WindowID argument missing"
    fi
    
    window_id=$1    
    ;;

  activate)
    action=$1
    ;;

  reset)
    action=$1
    ;;

  status)
    action=$1
    ;;
    
  *)
    exit_failure_syntax "unknown command '$1'"
    ;;
esac



detectDE

if [ "$action" = "resume" ] ; then
    do_resume
    exit_success
fi

perform_action "$action"

if [ "$action" = "suspend" ] ; then
    # Start tracking $window_id and resume the screensaver once it disappears
    ( track_window  ) 2> /dev/null > /dev/null &
fi        

if [ $? -eq 0 ]; then
    exit_success
elif [ $xset_err -eq 0 ]; then
    exit_success
else
    exit_failure_operation_failed
fi
