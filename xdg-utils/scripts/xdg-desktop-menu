#!/bin/sh
#---------------------------------------------
#   xdg-desktop-menu
#
#   Utility script to install menu items on a Linux desktop.
#   Refer to the usage() function below for usage.
#
#   Copyright 2006, Kevin Krammer <kevin.krammer@gmx.at>
#   Copyright 2006, Jeremy White <jwhite@codeweavers.com>
#
#   LICENSE:
#
#   Permission is hereby granted, free of charge, to any person obtaining a
#   copy of this software and associated documentation files (the "Software"),
#   to deal in the Software without restriction, including without limitation
#   the rights to use, copy, modify, merge, publish, distribute, sublicense,
#   and/or sell copies of the Software, and to permit persons to whom the
#   Software is furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included
#   in all copies or substantial portions of the Software.
#
#   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
#   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
#   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
#   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
#   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#   OTHER DEALINGS IN THE SOFTWARE.
#
#---------------------------------------------

manualpage()
{
cat << _MANUALPAGE
Name

xdg-desktop-menu - command line tool for (un)installing desktop menu items

Synopsis

xdg-desktop-menu install [--noupdate] [--novendor] [--mode mode] directory-file
(s) desktop-file(s)

xdg-desktop-menu uninstall [--noupdate] [--mode mode] directory-file(s)
desktop-file(s)

xdg-desktop-menu forceupdate [--mode mode]

xdg-desktop-menu { --help | --manual | --version }

Description

The xdg-desktop-menu program can be used to install new menu entries to the
desktop's application menu.

The application menu works according to the XDG Desktop Menu Specification at
http://www.freedesktop.org/Standards/menu-spec

Commands

install

    Install one or more applications in a submenu of the desktop menu system.

    directory-file: The *.directory file indicated by directory-file represents
    a submenu. The directory file provides the name and icon for a submenu. The
    name of the directory file is used to identify the submenu.

    If multiple directory files are provided each file will represent a submenu
    within the menu that preceeds it, creating a nested menu hierarchy
    (sub-sub-menus). The menu entries themselves will be added to the last
    submenu.

    Directory files follow the syntax defined by the freedesktop.org Desktop
    Entry Specification.

    desktop-file: A desktop file represents a single application in the menu.
    Desktop files are defined by the freedesktop.org Desktop Entry
    Specification. The most important aspects of *.desktop files are summarized
    below.

    If multiple desktop-files are specified, multiple entries will be added to
    the same menu. If entries are installed to a menu that has been created
    with a previous call to xdg-desktop-menu the entries will be installed in
    addition to any already existing entries.

uninstall

    Remove applications or submenus from the desktop menu system previously
    installed with xdg-desktop-menu install.

    A submenu and the associated directory file is only removed when the
    submenu no longer contains any menu entries.

forceupdate

    Force an update of the menu system.

    This command is only useful if the last call to xdg-desktop-menu included
    the --noupdate option.

Options

--noupdate
    Postpone updating the menu system. If multiple updates to the menu system
    are made in sequence this flag can be used to indicate that additional
    changes will follow and that it is not necassery to update the menu system
    right away.
--novendor

    Normally, xdg-desktop-menu checks to ensure that any *.directory and
    *.desktop files to be installed has a vendor prefix. This option can be
    used to disable that check.

    A vendor prefix consists of alpha characters ([a-zA-Z]) and is terminated
    with a dash ("-"). Companies and organizations are encouraged to use a word
    or phrase, preferably the organizations name, for which they hold a
    trademark as their vendor prefix. The purpose of the vendor prefix is to
    prevent name conflicts.

--mode mode

    mode can be user or system. In user mode the file is (un)installed for the
    current user only. In system mode the file is (un)installed for all users
    on the system. Usually only root is allowed to install in system mode.

    The default is to use system mode when called by root and to use user mode
    when called by a non-root user.

--help
    Show command synopsis.
--manual
    Show this manualpage.
--version
    Show the xdg-utils version information.

Directory Files

The appearance of submenu in the application menu is provided by a *.directory
file. In particular it provides the title of the submenu and a possible icon. A
*.directory file consists of a [Desktop Entry] header followed by several Key=
Value lines.

A *.directory file can provide a title (name) for the submenu in several
different languages. This is done by adding a language code as used by
LC_MESSAGES in square brackets behind the Key. This way one can specify
different values for the same Key depending on the currently selected language.

The following keys are relevqnt for submenus:

Value=1.0
    This is a mandatory field to indicate that the *.directory file follows the
    1.0 version of the Desktop Entry specification.
Type=Directory
    This is a mandatory field that indicates that the *.directory file
    describes a submenu.
Name=Menu Name
    The title of submenu. For example Mozilla
Comment=Comment
    Optional field to specify a tooltip for the submenu.
Icon=Icon File
    The icon to use for the submenu. This can either be an absolute path to an
    image file or an icon-name. If an icon-name is provided an image lookup by
    name is done in the user's current icon theme. The xdg-icon-resource
    command can be used to install image files into icon themes. The advantage
    of using an icon-name instead of an absolute path is that with an icon-name
    the submenu icon can be provided in several different sizes as well as in
    several differently themed styles.

Desktop Files

An application item in the application menu is represented by a *.desktop file.
A *.desktop file consists of a [Desktop Entry] header followed by several Key=
Value lines.

A *.desktop file can provide a name and description for an application in
several different languages. This is done by adding a language code as used by
LC_MESSAGES in square brackets behind the Key. This way one can specify
different values for the same Key depending on the currently selected language.

The following keys are often used:

Value=1.0
    This is a mandatory field to indicate that the *.desktop file follows the
    1.0 version of the specification.
Type=Application
    This is a mandatory field that indicates that the *.desktop file describes
    an application launcher.
Name=Application Name
    The name of the application. For example Mozilla
GenericName=Generic Name
    A generic description of the application. For example Web Browser
Comment=Comment
    Optional field to specify a tooltip for the application. For example Visit
    websites on the Internet
Icon=Icon File
    The icon to use for the application. This can either be an absolute path to
    an image file or an icon-name. If an icon-name is provided an image lookup
    by name is done in the user's current icon theme. The xdg-icon-resource
    command can be used to install image files into icon themes. The advantage
    of using an icon-name instead of an absolute path is that with an icon-name
    the application icon can be provided in several different sizes as well as
    in several differently themed styles.
Exec=Command Line
    The command line to start the application. If the application can open
    files the %f placeholder should be specified. When a file is dropped on the
    application launcher the %f is replaced with the file path of the dropped
    file. If multiple files can be specified on the command line the %F
    placeholder should be used instead of %f. If the application is able to
    open URLs in addition to local files then %u or %U can be used instead of
    %f or %F.
MimeType=Mimetypes
    A list of mimetypes separated by semi-colons. This field is used to
    indicate which file types the application is able to open.

For a complete oveview of the *.desktop file format please visit http://
www.freedesktop.org/wiki/Standards/desktop-entry-spec

Environment Variables

xdg-desktop-menu honours the following environment variables:

XDG_UTILS_DEBUG_LEVEL
    Setting this environment variable to a non-zero numerical value makes
    xdg-desktop-menu do more verbose reporting on stderr. Setting a higher
    value increases the verbosity.

Exit Codes

An exit code of 0 indicates success while a non-zero exit code indicates
failure. The following failure codes can be returned:

1
    Error in command line syntax.
2
    One of the files passed on the command line did not exist.
3
    A required tool could not be found.
4
    The action failed.
5
    No permission to read one of the files passed on the command line.

See Also

xdg-desktop-icon(1), xdg-icon-resource(1), xdg-mime(1)

Examples

The company ShinyThings Inc. has developed an application named "WebMirror" and
would like to add it to the application menu. The company will use
"shinythings" as its vendor id. In this example the company ShinyThings Inc.
will add its own submenu to the desktop application menu consisting of a
"WebMirror" menu item and a "WebMirror Admin Tool" menu item.

First the company needs to create two .desktop files that describe the two menu
items:

shinythings-webmirror.desktop:

  [Desktop Entry]
  Encoding=UTF-8
  Type=Application

  Exec=webmirror
  Icon=shinythings-webmirror

  Name=WebMirror
  Name[nl]=WebSpiegel


shinythings-webmirror-admin.desktop:

  [Desktop Entry]
  Encoding=UTF-8
  Type=Application

  Exec=webmirror-admintool
  Icon=shinythings-webmirror-admintool

  Name=WebMirror Admin Tool
  Name[nl]=WebSpiegel Administratie Tool

In addition a .directory file needs to be created to provide a title and icon
for the sub-menu itself:

shinythings-webmirror.directory:

  [Desktop Entry]
  Encoding=UTF-8

  Icon=shinythings-webmirror-menu

  Name=WebMirror
  Name[nl]=WebSpiegel

These file can now be installed with:

xdg-desktop-menu install ./shinythings-webmirror.directory \
      ./shinythings-webmirror.desktop ./shinythings-webmirror-admin.desktop

The menu entries could also be installed one by one:

xdg-desktop-menu install --noupdate ./shinythings-webmirror.directory \
      ./shinythings-webmirror.desktop
xdg-desktop-menu install --noupdate ./shinythings-webmirror.directory \
      ./shinythings-webmirror-admin.desktop
xdg-desktop-menu forceupdate

Although the result is the same it is slightly more efficient to install all
files at the same time.

The *.desktop and *.directory files reference icons with the names webmirror,
webmirror-admin and webmirror-menu which should also be installed. In this
example the icons are installed in two different sizes, once with a size of
22x22 pixels and once with a size of 64x64 pixels:

xdg-icon-resource install --size 22 ./wmicon-22.png shinythings-webmirror.png
xdg-icon-resource install --size 22 ./wmicon-menu-22.png shinythings-webmirror-menu.png
xdg-icon-resource install --size 22 ./wmicon-admin-22.png shinythings-webmirror-admin.png
xdg-icon-resource install --size 64 ./wmicon-64.png shinythings-webmirror.png
xdg-icon-resource install --size 64 ./wmicon-menu-64.png shinythings-webmirror-menu.png
xdg-icon-resource install --size 64 ./wmicon-admin-64.png shinythings-webmirror-admin.png

_MANUALPAGE
}

usage()
{
cat << _USAGE
xdg-desktop-menu - command line tool for (un)installing desktop menu items

Synopsis

xdg-desktop-menu install [--noupdate] [--novendor] [--mode mode] directory-file
(s) desktop-file(s)

xdg-desktop-menu uninstall [--noupdate] [--mode mode] directory-file(s)
desktop-file(s)

xdg-desktop-menu forceupdate [--mode mode]

xdg-desktop-menu { --help | --manual | --version }

_USAGE
}

#@xdg-utils-common@

#----------------------------------------------------------------------------
#   Common utility functions included in all XDG wrapper scripts
#----------------------------------------------------------------------------

DEBUG()
{
  [ ${XDG_UTILS_DEBUG_LEVEL-0} -lt $1 ] && return 0;
  shift
  echo "$@" >&2
}

#-------------------------------------------------------------
# Exit script on successfully completing the desired operation

exit_success()
{
    if [ $# -gt 0 ]; then
        echo "$@"
        echo
    fi

    exit 0
}


#-----------------------------------------
# Exit script on malformed arguments, not enough arguments
# or missing required option.
# prints usage information

exit_failure_syntax()
{
    if [ $# -gt 0 ]; then
        echo "xdg-desktop-menu: $@" >&2
        echo "Try 'xdg-desktop-menu --help' for more information." >&2
    else
        usage
        echo "Use 'man xdg-desktop-menu' or 'xdg-desktop-menu --manual' for additional info."
    fi

    exit 1
}

#-------------------------------------------------------------
# Exit script on missing file specified on command line

exit_failure_file_missing()
{
    if [ $# -gt 0 ]; then
        echo "xdg-desktop-menu: $@" >&2
    fi

    exit 2
}

#-------------------------------------------------------------
# Exit script on failure to locate necessary tool applications

exit_failure_operation_impossible()
{
    if [ $# -gt 0 ]; then
        echo "xdg-desktop-menu: $@" >&2
    fi

    exit 3
}

#-------------------------------------------------------------
# Exit script on failure returned by a tool application

exit_failure_operation_failed()
{
    if [ $# -gt 0 ]; then
        echo "xdg-desktop-menu: $@" >&2
    fi

    exit 4
}

#------------------------------------------------------------
# Exit script on insufficient permission to read a specified file

exit_failure_file_permission_read()
{
    if [ $# -gt 0 ]; then
        echo "xdg-desktop-menu: $@" >&2
    fi

    exit 5
}

#------------------------------------------------------------
# Exit script on insufficient permission to read a specified file

exit_failure_file_permission_write()
{
    if [ $# -gt 0 ]; then
        echo "xdg-desktop-menu: $@" >&2
    fi

    exit 6
}

check_input_file()
{
    if [ ! -e "$1" ]; then
        exit_failure_file_missing "file '$1' does not exist"
    fi
    if [ ! -r "$1" ]; then
        exit_failure_file_permission_read "no permission to read file '$1'"
    fi
}

check_vendor_prefix()
{
    file=`basename "$1"`
    case "$file" in
       [a-zA-Z]*-*)
         return
         ;;
    esac

    echo "xdg-desktop-menu: filename '$file' does not have a proper vendor prefix" >&2
    echo 'A vendor prefix consists of alpha characters ([a-zA-Z]) and is terminated' >&2
    echo 'with a dash ("-"). An example filename is '"'example-$file'" >&2
    echo "Use --novendor to override or 'xdg-desktop-menu --manual' for additional info." >&2
    exit 1
}

check_output_file()
{
    # if the file exists, check if it is writeable
    # if it does not exists, check if we are allowed to write on the directory
    if [ -e "$1" ]; then
        if [ ! -w "$1" ]; then
            exit_failure_file_permission_write "no permission to write to file '$1'"
        fi
    else
        DIR=`dirname "$1"`
        if [ ! -w "$DIR" -o ! -x "$DIR" ]; then
            exit_failure_file_permission_write "no permission to create file '$1'"
        fi
    fi
}

#----------------------------------------
# Checks for shared commands, e.g. --help

check_common_commands()
{
    while [ $# -gt 0 ] ; do
        parm="$1"
        shift

        case "$parm" in
            --help)
            usage
            echo "Use 'man xdg-desktop-menu' or 'xdg-desktop-menu --manual' for additional info."
            exit_success
            ;;

            --manual)
            manualpage
            exit_success
            ;;

            --version)
            echo "xdg-desktop-menu 1.0beta3"
            exit_success
            ;;
        esac
    done
}

check_common_commands "$@"
if [ ${XDG_UTILS_DEBUG_LEVEL-0} -lt 1 ]; then
    # Be silent
    xdg_redirect_output=" > /dev/null 2> /dev/null"
else
    # All output to stderr
    xdg_redirect_output=" >&2"
fi

#--------------------------------------
# Checks for known desktop environments
# set variable DE to the desktop environments name, lowercase

detectDE()
{
    if [ x"$KDE_FULL_SESSION" = x"true" ]; then DE=kde;
    elif [ x"$GNOME_DESKTOP_SESSION_ID" != x"" ]; then DE=gnome;
    elif xprop -root _DT_SAVE_MODE | grep ' = \"xfce4\"$' >/dev/null 2>&1; then DE=xfce;
    fi
}

#----------------------------------------------------------------------------
# kfmclient exec/openURL can give bogus exit value in KDE <= 3.5.4
# It also always returns 1 in KDE 3.4 and earlier
# Simply return 0 in such case

kfmclient_fix_exit_code()
{
    version=`kde-config --version 2>/dev/null | grep KDE`
    major=`echo $version | sed 's/KDE: \([0-9]\).*/\1/'`
    minor=`echo $version | sed 's/KDE: [0-9]*\.\([0-9]\).*/\1/'`
    release=`echo $version | sed 's/KDE: [0-9]*\.[0-9]*\.\([0-9]\).*/\1/'`
    test "$major" -gt 3 && return $1
    test "$minor" -gt 5 && return $1
    test "$release" -gt 4 && return $1
    return 0
}

update_desktop_database()
{
#    echo Update desktop database: $mode
    if [ "$mode" = "system" ] ; then
        for x in `echo $PATH | sed 's/:/ /g'` /opt/gnome/bin; do
           if [ -x $x/update-desktop-database ] ; then
              DEBUG 1 "Running $x/update-desktop-database"
              eval '$x/update-desktop-database'$xdg_redirect_output
              return
           fi
        done
    fi
}

update_submenu()
{
    DEBUG 1 "update_submenu $1"
    menu_file="$1"

    xdg_dir_name=menus
    xdg_user_dir="$XDG_CONFIG_HOME"
    [ -n "$xdg_user_dir" ] || xdg_user_dir="$HOME/.config"
    xdg_user_dir="$xdg_user_dir/$xdg_dir_name"

    xdg_system_dirs="$XDG_CONFIG_DIRS"
    [ -n "$xdg_system_dirs" ] || xdg_system_dirs=/etc/xdg
    xdg_global_dir=
    for x in `echo $xdg_system_dirs | sed 's/:/ /g'` ; do
        if [ -w $x/$xdg_dir_name ] ; then
            xdg_global_dir="$x/$xdg_dir_name"
            break
        fi
    done
    xdg_user_dir="$xdg_user_dir/applications-merged"
    xdg_global_dir="$xdg_global_dir/applications-merged"

    DEBUG 3 "Install locations for *.menu file:" 
    DEBUG 3 "xdg_user_dir: $xdg_user_dir"
    DEBUG 3 "xdg_global_dir: $xdg_global_dir"
    DEBUG 3 "kde_user_dir: $kde_user_dir"
    DEBUG 3 "kde_global_dir: $kde_global_dir"
    DEBUG 3 "gnome_user_dir: $gnome_user_dir"
    DEBUG 3 "gnome_global_dir: $gnome_global_dir"

    if [ x"$mode" = x"user" ] ; then
        xdg_dir="$xdg_user_dir"
        kde_dir="$kde_user_dir"
        gnome_dir="$gnome_user_dir"
        my_umask=077
    else
        xdg_dir="$xdg_global_dir"
        kde_dir="$kde_global_dir"
        gnome_dir="$gnome_global_dir"
        my_umask=022
        if [ -z "${xdg_dir}${kde_dir}${gnome_dir}" ] ; then
            exit_failure_operation_impossible "No writable system menu directory found."
        fi
    fi

    orig_menu_file=$xdg_dir/$menu_file

    DEBUG 1 "Updating $orig_menu_file ($action)"

    tmpfile=`mktemp`
    orig_desktop_files=
    if [ -r "$orig_menu_file" ] ; then
        awk '
# List all files within <Filename> tags
BEGIN {
  RS="<"
}
/^Filename/ {
  if (match($0,/>/)) {
     print substr($0,RSTART+1)
  }
}' $orig_menu_file > $tmpfile
    fi

    orig_desktop_files=`cat $tmpfile`
    new_desktop_files=
    if [ $action = "install" ] ; then
        for desktop_file in $desktop_files; do
            basefile=`basename $desktop_file`
            if ! grep '^'$basefile'$' $tmpfile > /dev/null 2> /dev/null ; then
            	# Append
            	echo "$basefile" >> $tmpfile
            fi
        done
        new_desktop_files=`cat $tmpfile`
    fi
    if [ $action = "uninstall" ] ; then
        echo > $tmpfile
        for desktop_file in $desktop_files; do
            echo "$desktop_file" >> $tmpfile
        done
        # Files to uninstall are listed in $tmpfile
        # Existing files are in $orig_desktop_files
        for desktop_file in $orig_desktop_files; do
            if ! grep '^'$desktop_file'$' $tmpfile > /dev/null 2> /dev/null; then
            	# Keep this file, it's not in the uninstall list
            	new_desktop_files="$new_desktop_files $desktop_file"
            fi
        done
    fi
    rm -f "$tmpfile"
    
    DEBUG 3 "Files to list in $menu_file: $new_desktop_files"
    
    if [ -n "$new_desktop_files" ] ; then
        # Install/update
        tmpfile=`mktemp`
        (
            echo '<!DOCTYPE Menu PUBLIC "-//freedesktop//DTD Menu 0.8//EN"'
            echo '    "http://www.freedesktop.org/standards/menu-spec/menu-0.8.dtd">'
            echo '<!-- Do not edit manually - generated and managed by xdg-desktop-menu -->'
            echo '<Menu>'
            echo '    <Name>Applications</Name>'

            for desktop_file in $directory_files; do
                basefile=`basename $desktop_file`
                basefilename=`echo "$basefile"|cut -d '.' -f 1`
                echo "<Menu>"
                echo "    <Name>$basefilename</Name>"
                echo "    <Directory>$basefile</Directory>"
            done

            echo "    <Include>"
            for desktop_file in $new_desktop_files; do
                echo "        <Filename>$desktop_file</Filename>"
            done
            echo "    </Include>"

            for desktop_file in $directory_files; do
                echo "</Menu>"
            done

            echo '</Menu>'                        
        ) > $tmpfile
    
        save_umask=`umask`
        umask $my_umask

        mkdir -p $xdg_dir
        eval 'cp $tmpfile $xdg_dir/$menu_file'$xdg_redirect_output

        umask $save_umask
	rm -f "$tmpfile"
    else
        # Uninstall
        rm -f $xdg_dir/$menu_file
    fi
    
    # Uninstall .directory files only if no longer referenced
    if [ $action = "uninstall" ] ; then
        tmpfile=`mktemp`
        for menu_file in $xdg_dir/*; do
            if grep 'generated and managed by xdg-desktop-menu' $menu_file > /dev/null 2> /dev/null; then
                awk '
# List all files within <Directory> tags
BEGIN {
  RS="<"
}
/^Directory/ {
  if (match($0,/>/)) {
     print substr($0,RSTART+1)
  }
}' $menu_file >> $tmpfile
            fi
        done 
        orig_directory_files="$directory_files"
        directory_files=
        for desktop_file in $orig_directory_files; do
            if ! grep '^'$desktop_file'$' $tmpfile > /dev/null 2> /dev/null; then
                # No longer in use, safe to delete
               directory_files="$directory_files $desktop_file"
            fi
        done
        rm -f "$tmpfile"
    fi
}


[ x"$1" != x"" ] || exit_failure_syntax

mode=
action=
update=yes
desktop_files=
directory_files=

case $1 in
  install)
    action=install
    ;;

  uninstall)
    action=uninstall
    ;;

  forceupdate)
    action=forceupdate
    ;;

  *)
    exit_failure_syntax "unknown command '$1'"
    ;;
esac

shift

vendor=true
while [ $# -gt 0 ] ; do
    parm="$1"
    shift

    case "$parm" in
      --noupdate)
        update=no
        ;;

      --mode)
        if [ -z "$1" ] ; then
            exit_failure_syntax "mode argument missing for --mode"
        fi
        case "$1" in
          user)
            mode=user
            ;;

          system)
            mode=system
            ;;
            
          *)
            exit_failure_syntax "unknown mode '$1'"
            ;;
        esac
        shift
        ;;

      --novendor)
        vendor=false
        ;;

      -*)
        exit_failure_syntax "unexpected option '$parm'"
        ;;

      *)
        if [ "$action" = "install" ] ; then
            check_input_file "$parm"
        fi
        case "$parm" in
           *.directory)
              if [ -n "$desktop_files" ] ; then
                  exit_failure_syntax "'$parm' must preceed any *.desktop file"
              fi
              directory_files="$directory_files $parm"
              ;;
           *.desktop)
              desktop_files="$desktop_files $parm"
              ;;
           *)
              exit_failure_syntax "file to $action must be a *.directory or *.desktop file"
              ;;
        esac
        ;;
    esac
done

# Shouldn't happen
if [ -z "$action" ] ; then
    exit_failure_syntax "command argument missing"
fi

if [ -z "$mode" ] ; then
    if [ `whoami` = "root" ] ; then
       mode=system
    else
       mode=user
    fi
fi

if [ x"$action" = x"forceupdate" ] ; then
    update_desktop_database
    exit_success
fi

if [ -z "$desktop_files" ] ; then
    exit_failure_syntax "desktop-file argument missing"
fi

menu_name=
for desktop_file in $directory_files; do
    if [ "$vendor" =  "true" -a "$action" = "install" ] ; then
        check_vendor_prefix "$desktop_file"
    fi

    basefilename=`basename "$desktop_file"|cut -d '.' -f 1`
    if [ -z "$menu_name" ] ; then
        menu_name="$basefilename"
    else
        menu_name="$menu_name-$basefilename"
    fi
done

if [ -n "$menu_name" ] ; then
    if [ x"$mode" = x"user" ] ; then
        update_submenu "user-$menu_name.menu"
    else
        update_submenu "$menu_name.menu"
    fi
fi

# Install *.directory files

xdg_dir_name=desktop-directories

xdg_user_dir="$XDG_DATA_HOME"
[ -n "$xdg_user_dir" ] || xdg_user_dir="$HOME/.local/share"
xdg_user_dir="$xdg_user_dir/$xdg_dir_name"

xdg_system_dirs="$XDG_DATA_DIRS"
[ -n "$xdg_system_dirs" ] || xdg_system_dirs=/usr/local/share/:/usr/share/
xdg_global_dir=
for x in `echo $xdg_system_dirs | sed 's/:/ /g'` ; do
    if [ -w $x/$xdg_dir_name ] ; then
        xdg_global_dir="$x/$xdg_dir_name"
        break
    fi
done

DEBUG 3 "Install locations for *.directory files:" 
DEBUG 3 "xdg_user_dir: $xdg_user_dir"
DEBUG 3 "xdg_global_dir: $xdg_global_dir"
DEBUG 3 "kde_user_dir: $kde_user_dir"
DEBUG 3 "kde_global_dir: $kde_global_dir"
DEBUG 3 "gnome_user_dir: $gnome_user_dir"
DEBUG 3 "gnome_global_dir: $gnome_global_dir"

if [ x"$mode" = x"user" ] ; then
    xdg_dir="$xdg_user_dir"
    kde_dir="$kde_user_dir"
    gnome_dir="$gnome_user_dir"
    my_umask=077
else
    xdg_dir="$xdg_global_dir"
    kde_dir="$kde_global_dir"
    gnome_dir="$gnome_global_dir"
    my_umask=022
    if [ -z "${xdg_dir}${kde_dir}${gnome_dir}" ] ; then
        exit_failure_operation_impossible "No writable system menu directory found."
    fi
fi

for desktop_file in $directory_files; do
    basefile=`basename $desktop_file`

    DEBUG 1 "$action $desktop_file in $xdg_dir $kde_dir $gnome_dir"

    case $action in
        install)
            save_umask=`umask`
            umask $my_umask

            for x in $xdg_dir $kde_dir $gnome_dir ; do
                mkdir -p $x
                eval 'cp $desktop_file $x/$basefile'$xdg_redirect_output
            done

            umask $save_umask
            ;;

        uninstall)
            for x in $xdg_dir $kde_dir $gnome_dir ; do
                rm -f $x/$basefile
            done

            ;;
    esac
done

# Install *.desktop files
xdg_dir_name=applications

xdg_user_dir="$XDG_DATA_HOME"
[ -n "$xdg_user_dir" ] || xdg_user_dir="$HOME/.local/share"
xdg_user_dir="$xdg_user_dir/$xdg_dir_name"

xdg_system_dirs="$XDG_DATA_DIRS"
[ -n "$xdg_system_dirs" ] || xdg_system_dirs=/usr/local/share/:/usr/share/
xdg_global_dir=
for x in `echo $xdg_system_dirs | sed 's/:/ /g'` ; do
    if [ -w $x/$xdg_dir_name ] ; then
        xdg_global_dir="$x/$xdg_dir_name"
        break
    fi
done

kde_user_dir="$HOME/.kde/share/applnk"
kde_global_dir="/usr/share/applnk"
[ -w $kde_global_dir ] || kde_global_dir=

gnome_user_dir="$HOME/.gnome/apps"
gnome_global_dir="/usr/share/gnome/apps"
[ -w $gnome_global_dir ] || gnome_global_dir=

DEBUG 3 "Install locations for *.desktop files:" 
DEBUG 3 "xdg_user_dir: $xdg_user_dir"
DEBUG 3 "xdg_global_dir: $xdg_global_dir"
DEBUG 3 "kde_user_dir: $kde_user_dir"
DEBUG 3 "kde_global_dir: $kde_global_dir"
DEBUG 3 "gnome_user_dir: $gnome_user_dir"
DEBUG 3 "gnome_global_dir: $gnome_global_dir"

if [ x"$mode" = x"user" ] ; then
    xdg_dir="$xdg_user_dir"
    kde_dir="$kde_user_dir"
    gnome_dir="$gnome_user_dir"
    my_umask=077
else
    xdg_dir="$xdg_global_dir"
    kde_dir="$kde_global_dir"
    gnome_dir="$gnome_global_dir"
    my_umask=022
    if [ -z "${xdg_dir}${kde_dir}${gnome_dir}" ] ; then
        exit_failure_operation_impossible "No writable system menu directory found."
    fi
fi

for desktop_file in $desktop_files; do
    if [ "$vendor" =  "true" -a "$action" = "install" ] ; then
        check_vendor_prefix "$desktop_file"
    fi

    basefile=`basename $desktop_file`

    DEBUG 1 "$action $desktop_file in $xdg_dir $kde_dir $gnome_dir"

    case $action in
        install)
            save_umask=`umask`
            umask $my_umask

            for x in $xdg_dir $kde_dir $gnome_dir ; do
                mkdir -p $x
                eval 'cp $desktop_file $x/$basefile'$xdg_redirect_output
            done

            if [ -f $kde_dir/$basefile ] ; then
                echo "OnlyShowIn=Old;" >> $kde_dir/$basefile
            fi

            if [ -f $gnome_dir/$basefile ] ; then
                echo "OnlyShowIn=Old;" >> $gnome_dir/$basefile
            fi

            umask $save_umask
            ;;

        uninstall)
            for x in $xdg_dir $kde_dir $gnome_dir ; do
                rm -f $x/$basefile
            done

            ;;
    esac
done

if [ x"$update" = x"yes" ] ; then
    update_desktop_database
fi

exit_success
